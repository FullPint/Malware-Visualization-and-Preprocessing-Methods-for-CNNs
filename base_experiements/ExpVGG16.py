# Standard Lib Imports
import os
import glob

# Package Imports
from keras.applications.vgg16 import VGG16
from keras.preprocessing.image import ImageDataGenerator
from keras import optimizers
from keras.layers import Input, Flatten, Dense
from keras.models import Model
from keras.utils import multi_gpu_model

import numpy as np
import pandas as pd

# User Defined Imports and Constants


class ExpVGG16:
    def __init__(self, name, batch_size=6, epochs=25, val_split=0.2, multi_gpu=True):
        self.name = name
        self.batch_size = batch_size
        self.epochs = epochs
        self.val_split = val_split
        self.multi_gpu = multi_gpu
        self.base_dir = os.getcwd()
        self.base_data_dir = os.path.join(self.base_dir, "data-sets")
        self.exp_data_dir_name = ""
        self.exp_data_dir = os.path.join(self.base_data_dir, self.exp_data_dir_name)
        self.base_saved_models_dir = os.path.join(self.base_dir, "saved-models")
        self.base_history_dir = os.path.join(self.base_data_dir, "saved-history")

    def get_image_dirs(self):
        return glob.glob(self.exp_data_dir + "/*/")

    def get_data_gen(self):
        return ImageDataGenerator(validation_split=self.val_split)

    def get_train_validation_flows(self, img_gen):
        return (
            img_gen.flow_from_directory(self.exp_data_dir, subset="training"),
            img_gen.flow_from_directory(self.exp_data_dir, subset="validation"),
        )

    def build_model(self, number_of_labels):
        # Get back the convolutional part of a VGG network trained on ImageNet
        model_vgg16_conv = VGG16(weights=None, include_top=False)

        # Creating New Input
        input = Input(shape=(256, 256, 3), name="mal_img_input")

        # Using Generated Model
        output_vgg16_conv = model_vgg16_conv(input)

        # Add the fully-connected layers
        x = Flatten(name="flatten")(output_vgg16_conv)
        x = Dense(4096, activation="relu", name="fc1")(x)
        x = Dense(4096, activation="relu", name="fc2")(x)
        x = Dense(number_of_labels, activation="softmax", name="mal_img_predict")(x)

        # Returning Model Either Multi GPU or Single GPU Model
        if self.multi_gpu:
            return multi_gpu_model(Model(inputs=input, outputs=x), gpus=2)
        else:
            return Model(inputs=input, outputs=x)

    # Compiling Model to Run
    def compile_model(self, model):
        model.compile(
            optimizer=optimizers.SGD(),
            loss="categorical_crossentropy",
            metrics=["accuracy", "sparse_categorical_crossentropy"],
        )

    def train_model(self, model, train, val):

        print("Training...")
        return model.fit_generator(
            generator=train,
            steps_per_epoch=train.samples // DEFAULT_BATCH,
            validation_data=val,
            validation_steps=train.samples // DEFAULT_BATCH,
            epochs=self.epochs,
        )

    def evaluate_model(self, model, generator):
        print("Evaluating...")
        return model.evaluate_generator(generator)

    def save_model_history(self, history):
        hist_df = pd.DataFrame(history.history)

        with open(
            os.path.join(self.base_history_dir, self.name + ".json"), mode="w+"
        ) as f:
            hist_df.to_json(f)

        with open(
            os.path.join(self.base_history_dir, self.name + ".csv"), mode="w+"
        ) as f:
            hist_df.to_csv(f)

    def runExp(self):
        my_generator = get_data_gen()
        my_train, my_val = get_train_validation_flows(my_generator)

        # Passing the length of unique labels in to create output of model
        my_model = build_model(len(np.unique(my_train[1])))
        compile_model(my_model)
        print(my_model.summary())

        # Training Model
        history = train_model(my_model, my_train, my_val)

        # Evaluating Model w/ Scores To be printed and logged
        score, acc = my_model.evaluate_model(my_generator)
        print("Test score:", score)
        print("Test accuracy:", acc)

        # Saving Model and History
        my_model.save(os.path.join(self.base_saved_models_dir, self.name + ".h5"))
        save_model_history(history)
